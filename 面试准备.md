# 面试的准备内容

# C++相关

### `open`和`fopen`的区别

`open`是系统调用，它返回的是文件句柄，文件句柄是文件在描述符表里的索引。

`fopen`是C语言的库函数，返回的是一个指向文件结构的指针。

此外：

1. `open`属于低级IO，`fopen`是高级IO。
2. `open`返回一个文件描述符(用户程序区的)，`fopen`返回一个文件指针。
3. `open`无缓冲，`fopen`有缓冲。
4. `open`与 `read`, `write `等配合使用， `fopen`与 `fread`,`open`与 `read`, `write `等配合使用，
5. `fopen`是在open的基础上扩充而来的，在大多数情况下用`fopen`。

### STL迭代器

迭代器实际上就为STL中的各种容器提供一种统一的迭代方式，以此来提升一些算法的复用性，迭代器可以分成五类，**输入迭代器**、**输出迭代器**、**前向迭代器**、**双向迭代器**和**随机访问迭代器**。随机访问迭代器只有`vector`和`deque`，队列和栈不支持迭代器，其他的都是双向迭代器

### 多线程是如何实现的





### 从用户态到内核态

主要通过三种方式，分别为：**中断门**、**陷阱门**和**系统门**。

在Linux中又进行了细分，多分出了，**系统中断门**和**任务门。**





### 结构体的对齐方式

```cpp
typedef struct _Header {
	unsigned int   packFlag;   //4个字节
	unsigned short versions;   //2个字节
	unsigned int   serialNum;  //4个字节
	unsigned char  devStaFlag; //1个字节
	unsigned int   angleRes;   //4个字节
	unsigned long long   pulseNum;  //8个字节
	unsigned int   pointsCount; //4个字节
	_Header()
	{
		packFlag=0;   //4个字
		versions = 0;   //2个字
		serialNum = 0;  //4个字
		devStaFlag = '\0'; //1个字
		angleRes = 0;   //4个字
		pulseNum = 0; 
		pointsCount = 0; //4个
	}
}MY_FILE_HEADER;
```

上述的结构体，如果按字节一个一个数的话会发现，它占用的字节数应该是27，而当我们`sizeof`这个结构体时会发现这个结构体占用的时40是个字节，是什么导致它有这么大的差距呢，我们下面来一个一个捋一下。

首先`packFlag`，它在结构体的第一个，int型占用4个字节，这没什么疑问。**至此四个字节**

然后是`versions`它是`short`型占用两个字节，但是它的下一个成员`serialNum`是int型占用4个字节，那么如果让`version`占用2个字节，那么`serialNum`所在的地址起点就不能被它自己的字节数整除（(4+2)/4不能除出整数），为了避免这种情况发生，`versions`后面需要补充两个字节，来让`serialNum`的起始地址能够被整除（(4+4)/4能整除），所以`versions`占用的字节数是两个字节，但是它后面还要再填充两个字节用来补位，总共消耗了四个字节。**至此八个字节**

接下来是`serialNum`，它是int型，占用4个字节，它的下一个成员占用一个字节，那么目前看来`serialNum`占用4个字节没什么问题，**至此十二个字节**

接下来是`devStaFlag`，它是char类型，并被初始化成空，占用一个字节，它的下一个 成员`angleRes`是int占用4个字节，显然，如果`devStaFlag`后面不补充是不行的，现在一共是（4+(2+2)+4+1）=13字节，肯定不能被4整除，我们补充三个字节到16个字节，就可以被4整除了，**至此十六个字节**

接下来是`angleRes`它是int型，需要占用4个字节，而它的下一个成员`pulseNum`需要占用8个字节，我们来看下当前占用情况，（4+(2+2)+4+(1+3)+4）=20字节，而20字节不能被`pulseNum`的8字节整除，所以我们需要补充4个字节，使它能够被`pulseNum`的8字节整除，所以我们又需要补充4个字节，算上`angleRes`占用的4字节，一共是8字节，**至此是二十四字节。**

接下来是`pulseNum`，它是long long 类型，需要占用8个字节，它的下一个是int型占用四个字节，那么我们就不需要补充了，**至此是三十二字节。**

最后一个是`pointCount`它是int型占用4字节，而且是最后一个那么至此一共是**三十六字节。**

那么为什么是40个字节呢？原因是结构体本身还需要根据结构体内部占用内存最多的数据结构来对齐，在这个结构中最大的是8字节的，那么就需要结构体占用的总内存能够被8整除才行，所以就有需要补充4个字节，所以最终一共占用了**四十字节。**

可能你会好奇，为什么要这样做呢，这不是很浪费内存吗 ，实际上这样做的好处是能够节省寻址的时间，如果不做对齐处理，会很浪费寻址的时间，而并不是所有时候都是时间敏感的，有时候我们可能是内存敏感，C语言针对对齐方式有一个宏定义可以使用。

### `#pragma pack()`

实际上上面我们所讲到的是结构体的默认对齐方式，而`#pragma pack()`这个宏定义，可以让我们指定一个结构体的对齐方式，下面是它的用法： 实际上最常用的参数就算那个n了。

**功能**：改变变压器对齐的字节数
**用法详解**：

使用#pragma pack(push)会将当前的对齐字节数压入栈顶，并设置这个值为新的对齐字节数， 就是说不会改变这个值。
使用#pragma pack(push, n) 会将当前的对齐字节数压入栈顶，并设置n为新的对齐字节数。
使用#pragma pack(pop)会弹出栈顶对齐字节数，并设置其为新的内存对齐字节数。
使用#pragma pack(pop, n)情况就不同了， 他会弹出栈顶并直接丢弃，设置n为其新的内存对齐字节数。
使用#pragma pack(pop, identifier [, n])，编译器执行这条执行时会从栈顶向下顺序查找匹配的identifier，找到identifier相同的这个数之后将从栈顶到identifier，包括找到identifier全部pop弹出， 若没有找到则不进行任何操作。

**例子和用法**：

```cpp
#pragma pack(show) //显示当前内存对齐的字节数，编辑器默认4字节对齐
#pragma pack(n) //设置编译器按照n个字节对齐，n可以取值1,2,4,8,16
#pragma pack(0) //恢复编译器默认对齐方式
#pragma pack() //恢复编译器默认对齐方式
#pragma pack(push) //将当前的对齐字节数压入栈顶，不改变对齐字节数
#pragma pack(push,n) //将当前的对齐字节数压入栈顶，并按照n字节对齐
#pragma pack(pop) //弹出栈顶对齐字节数，不改变对齐字节数
#pragma pack(pop,n) //弹出栈顶并直接丢弃，按照n字节对齐
```



当在结构体前`#pragma pack(n)`时，结构体就会按照n来对齐，在上述例子中，当n=4，结构体的字节数为32字节；n=2，结构体的字节数为28字节；n=1，结构体的字节数为27字节；当n>=8时，字节数都是40。也就是说当n大于默认对齐方式时它会被忽略

### `alignas()`

与`#pragma pack()`相对的在C++11中还引入了，`alignas()`这种对齐方式，它与`#pragma pack()`正相反，它可以提高对齐的字节数，即大于默认对齐时才有效，而小于默认对齐时会被忽略。

它的用法也与`#pragma pack()`有所不同，`#pragma pack()`是宏定义，写在要作用的结构体的前一行，而`alignas()`则在结构体关键字`struct `之后，即`struct alignas()`。

### `__attribute__ ((attribute-list))`

除了上述的两种方法可以改变结构体的内存对齐外，在GCC中，还可以用`__attribute__ ((attribute-list))`的方法，其中参数列表`(attribute-list)`可以有六个参数：`aligned`, `packed`, `transparent_union`, `unused`, `deprecated`和 `may_alias`，其中前两个我们看着很熟悉，他们两个就可以改变对齐方式，其中`__attribute__((packed))`就算用最节省内存的方式进行对齐，也就是1字节。它所在的位置与前两种方法也不一样，它好像放在`;`前都可以，但是应该不能放在`{}`内。

```cpp
typedef struct __attribute__((packed)) {
    UInt8 cmd;
    UInt16 index;
} D2MCommand;

typedef struct {
    UInt8 cmd;
    UInt16 index;
} D2MCommand __attribute__((packed));
```

` __attribute__((aligned(n)))：`此属性指定了指定类型的变量的最小对齐(以字节为单位)。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。

注意：对齐属性的有效性会受到链接器(linker)固有限制的限制，即如果你的链接器仅仅支持8字节对齐，即使你指定16字节对齐，那么它也仅仅提供8字节对齐。

# 操作系统相关



### Linux系统调用的三种方法





### 进程间通信

在Linux中进程间通信主要有七种方法，分别是无名管道、有名管道、消息队列、共享内存、信号量、信号和Socket。

#### 无名管道（pipe）

其中无名管道就是命令行中的`|`它的作用是将前一个命令的输出作为下一个命令的输入，无名管道只能用于有亲缘关系的进程之间，它被创建后，不会存在于文件系统中，它只存在于内存中，我们可以用以下命令创建管道：

```cpp
#include<unistd.h>//头文件

int pipe(int pipefd[2]); //函数 //创建成果返回0，失败返回1

int fd[2];
pipe(fd);
```

这样我们就创建出了一个名为`fd`的无名管道，注意，我们所说的无名管道的无名，是它与有名管道相比并不存在于文件系统中，在代码中我们对其是可见的，不然它也就没什么存在的意义了，因为我们很难操作它。

我们注意到`fd`是一个数组，其中`fd[0]`是用于接收数据的，也就是用于读取，`fd[1]`用于发送数据，我们可以将它看成一个单向通行的管道，`fd[0]`是管道的出口，而`fd[1]`则是管道的入口。

需要注意的是，这个管道只能存放一个数据，并且它有阻塞的性质：

1. 当写入数据时，管道中本身有数据没有被读取，那么写数据的进程会被阻塞。
2. 当读取数据时，管道中本身没有数据，那么读数据的进程会被阻塞。如果读取数据时管道中有数据，数据被读取后则会将管道中的数据自动删除。

管道也可以设置成非阻塞模式：

```cpp
//获取原来的flags
int flags = fcntl(fd[0],F_GETFL);
//设置新的flags
flag|=O_NONBLOCK;
//将新设置的flags更新到管道属性
fcntl(fd[0],F_SETFL,flags);
```

可以通过下面的函数来查看管道的缓冲区：

```cpp
long fpathconf(int fd,int name);
/*
*该函数可以根据name参数查看不同的属性值。
*@param fd 文件描述符
*@param name 	_PC_PIPE_BUF,查看管道缓冲区大小；
*				_PC_NAME_MAX,文件名字字节数的上线。
*@return 成功 返回name要查看的值，失败返回-1.
*/
```



#### 有名管道（FIFO）

有名管道与匿名管道的区别就是它可以在文件系统中被看到，但它的那个文件永远都是0KB，因为它的内容一直被保存在内存中，既然它存在于文件系统中，那么任何程序只有用友权限就可以对它进行读写了，并且它也不会随创建它的进程的销毁而消失，如果不主动删除，它会一直存在。

我们可以通过下面的函数创建一个有名管道：

```cpp
#include<sys/types.h>
#include<sys/stat.h>
 
int mkfifo(const char*pathname,mode_t mode);
 
//pathname -> 普通的路径名，也就是创建后FIFO的名字
//mode ->文件权限
//与打开普通文件的open()函数中的mode参数相同。(0666)
 
//返回值:
//    成功 ：0
//    失败： 如果文件已存在，则会出错且返回-1
```

创建之后，我们就可以通过文件操作的API对其进行操作，比如open、read和write等。

管道通信的原理实际上就是在内核中开辟了一个交换数据的区域。也就是说，管道的读取是需要进行内核态和用户态的切换的，所以其效率比较低，同时它的阻塞也会让效率变低。具体实现是在磁盘上的FIFO文件标识符占据`inode`区域，`inode`节点会指向内核开辟的内存上的一片空间，实际的内存交换是在内核开辟的内存上进行的，而不是在磁盘中。

有名管道的阻塞发生在文件open时，当一个进程用写的方式打开管道后，另一个进程用只读的方式打开管道，第一个进程的阻塞才会结束，反之如果以只读的方式先打开，也必须有另一个进程以写入的方式打开才能解除阻塞。

**注意:**
我们可以总结出有名管道需要注意的点：

* 以open方式打开管道文件会阻塞，直到有进程以另一种方式打开管道文件（读或写）。
* 如果管道对应的内存空间没有数据，则read会阻塞，直到内存中有数据或写端关闭返回0。
* 如果管道对应的内存空间已满，则write就会阻塞，直到内存中有空间或读端关闭返回0.
* 一个为只读而打开一个管道的进程会阻塞直到另一个进程为只写打开该管道
* 一个为只写而打开一个管道的进程会阻塞直到另一个进程为只读打开该管道





#### 消息队列

消息队列的原理和管道很像，它们都是由内核维护的，只不过消息队列的指定方式是用它的key来确认，并且这个key是人为确定的，也就是说只要有这个key，并且有相应的访问权限，任何程序都能访问这个消息队列。此外从名字中的队列可以看出来它里面可以储存很多消息，并且实际上它可以存多种不同类型的消息，我们从消息队列中读取消息的时候也不一定是从队列的头部开始读取，消息队列中的消息是有消息类型的，我们可以指定消息类型，然后直接读取在队列最前面的那个该类型的消息。并且队列中的内容也会在被读取后删除。

它主要有如下接口：

1) `msgget`

```cpp
int msgget(key_t key, int msqflg);
msgget()创建或者获取一个消息队列 
msgget()成功返回消息队列 ID，失败返回-1 
 
key值可以是人为指定的数字，强转为key_t类型即可，也可以通过ftok 函数获得。
人工指定key值:
（key_t)1234;//1234就为key值，在创建获取消息队列函数的第一个参数可以这样写
 
通过函数获取:
# include<sys/types.h>
# include<sys/ipc.h>
key_t ftok(const char* pathname,int proj_id);
             成功返回key值，失败返回-1
参数为：pathname ：路径名；
       proj_id：项目ID，非0整数，只有低8位有效。
 
msqflg：标识函数的行为及消息队列的权限
IPC_CREAT：创建消息队列
IPC_EXCL：检测消息队列是否存在
位或权限位：可以设置消息队列的访问权限，和其他两个参数可以或表示,如0600，仅拥有者具有文件的读取和写入权限
```

2) `msgsnd`

```cpp
int msgsnd(int msqid, const void *msqp, size_t msqsz, int msqflg); 
 
msgsnd()发送一条消息; 
 
//参数意义: 
msqid:消息队列的id,因为系统中可能有多个消息队列,这id指明往哪个消息队列中添加数 据; 
 
msqp:往消息队列中添加的结构体,消息结构为： 
 
struct msgbuf 
 
{
    long mtype; // 消息类型， 必须大于0(或者说>=1),长整型,比如图中的1,2 
 
    char mtext[1]; // 消息数据 ,用户自己定义,可以是任何类型;这里存放消息数据 
};
 
msqsz： 指定 mtext 中有效数据的长度//注意仅仅只接收的数据的大小,不包含消息类 型的大小; 
 
msqflg：一般设置为 0 可以设置 IPC_NOWAIT 
 
msgsnd()成功返回0,失败返回-1; 
```

3) `msgrcv`

```cpp
ssize_t msgrcv(int msqid, void *msgp, size_t msqsz, long msqtyp, int msqflg); 
 
msgrcv()接收一条消息 
 
msgrcv()成功返回 mtext 中接收到的数据长度， 失败返回-1, 
 
msgp:接收消息的结构体,一般约定好,写入什么,接收什么结构体; 
 
msqsz:接收消息的大小,大于等于发送的消息大小,一般和发送的消息大小一样. 
 
msqtyp： 指定接收的消息类型(图中的1和2)，类型可以为 0,为0表示不区分消息类型, 按顺位接收消息; 
 
msqflg： 一般设置为 0 可以设置 IPC_NOWAIT 
```

4) `msgctl` 主要用于删除

```cpp
int msgctl(int msqid, int cmd, struct msqid_ds *buf); 
 
msgctl()控制消息队列,也就是对消息队列做一个控制,可以设置消息队列,也可以移除消息队列; 
 
msgctl()成功返回 0，失败返回-1 
 
msqid:消息标识符，即由msgget返回的消息队列表示码
 
cmd
（1）IPC_STAT：把msqid_ds结构体中个元素的当前值存入到由buf指向的结构体中。
（2）IPC_SET：把msqid结构体中的元素设置为buf中的对应值。
（3）IPC_RMID：从系统中删除该消息队列以及仍在该队列中的所有数据，这种删除立即生效。
 
buf:设置或者获取消息队列需要的一个结构体,如果删除就直接给一个NULL;
msgctl(msgid,IPC_RMID,NULL);
消息队列在内存中创建;
```



#### 信号量

信号量实际上就是`mutex`锁，或者说它可以替代锁，区别是它可以设置成大于1的值，当信号量的值只取0和1时则称其为**二值信号量**，若信号量取值大于一则称之为**计数信号量**，除了创建、获取和删除信号量，我们还可以对信号量有两个原子操作，分别是`P`操作和`V`操作，其中`P`操作可以将信号量的值减一，`V`操作则可以将信号量的值加一，当信号量的值为0时进行`P`操作会被阻塞，直到当前正在使用该信号的进程使用`V`操作将信号量加一后，刚刚的`P`操作才会恢复。

信号量有如下三种接口可以调用：

1. `semget`创建/获取信号量集合

```cpp
int semget(key_t key,int nsems,int semflg);
 
创建或者获取一个已经存在的信号量;
 
key:两个进程使用相同的key值,就可以使用同一个信号量;
 
nsems:创建几个信号量;
 
semflg:标志位;如果为创建:IPC_CREAT;
             IPC_EXCL:检测信号量集合是否存在
             位或权限位:可以设置信号量集合的访问权限，和其他两个参数可以或表示 
 
返回值，成功则返回信号量的ID。
//运行的时候:./a& ./b&
 
如果为全新创建,也就是不知道是否有人创建过,则IPC_CREATE|IPC_EXCEL,就是如果
 
没有则创建,如果有则创建失败 ;
```

2. `semop`操作信号量

```cpp
int semop(int semid,struct sembuf *sops,unsigned nsops); 
 
对信号量进行改变,做P操作或者V操作;
 
semid:信号量的id号,也就是刚才semget的返回值;说明对哪个信号量进行操作;
 
sops:结构体指针,指向sembuf的结构体指针,
 
sembuf结构体有三个成员变量:
sem_num表示信号量的编号(即指定信号量集中的信号量下标);
sem_op表示是p还是v操作;1为v操作(加1),-1为p操作(减1);
若此时已经没有资源了进行-1操作：
    
sem_flg为标志位：
IPC_NOWAIT 对信号的操作不能满足时， semop()不会阻塞，并立即返回，同时设定错误信息。
SEM_UNDO 程序结束时(不论正常或不正常)，保证信号值会被重设为semop()调用前的值。这样做的目的在于避免程序在异常情况下结束时未将锁定的资源解锁，造成该资源永远锁定。
 
nsops：信号操作结构的数量，恒大于或等于1。

struct sembuf{
     unsigned short sem_num;//信号量ID
     short          sem_op; //信号量操作
     short          sem_flg;//操作标志
}；
```

3. `semctl`设置信号量集合

```cpp
int semctl(int semid,int semnum,int cmd,...); 
 
对信号量进行控制:初始化/删除信号量
 
semid:信号量id;
 
semnum:信号量编号;
 
cmd:命令:SETVAL:初始化信号量; IPC_RMID:删除信号量;
 
**注意**:联合体semun,这个联合体需要自己定义;
union semun{
   int              val;   //信号量的值
   struct semid_ds* buf;   // ipc_stat,ipc_set的缓冲区
   unsigned short* array;  //SETALL,GETALL数组
   struct seminfo* _buf;   //ipc_info缓冲区(Linux专用) 
};
```

总之使用一个信号量的大致流程如下。

1. **创建信号量：**利用`semget()`函数进行创建，入口参数分别为信号量的key、个数和创建还是查看是否存在，并且确定权限。最后会返回一个`int`型的值就是信号量的ID如果是-1则说明创建失败。
2. **初始化信号量：**信号量在创建后需要利用`semctl()`进行初始化，第一个参数是信号量的ID，第二个参数是信号量的index，第三个参数是命令，在初始化时第三个参数为`SETVAL`，第四个参数，初始化的联合体`semun`需要我们自己来定义，一般我们只需要定义一个`int`型的val就可以了，这个val就是信号量的值。需要注意的是，我们之前创建的每一个信号量数组中的每一个元素都要初始化。
3. **操作信号量：**操作信号量前需要先创建一个设置一个结构体`sembuf`这个结构体的第一个成员`sem_num`是index，指示我们要操作信号量组中的哪一个，第二个成员`sme_op`是`+1`和`-1`正一表示是V操作，负一表示是P操作。第三个成员`sem_flg`一般设置为`SEM_UNDO`，设置好结构体后我们调用`semop()`函数，它的第一个参数为ID，第二个参数就是我们刚刚定义的结构体的地址，第三个参数一般设定为1。
4. **删除信号量：**删除信号量只要调用`semctl`函数，第一个参数是ID，第二个参数设定为0，第三个参数为`IP_RMID`，运行完这个函数后该信号量就被删除了。



#### 共享内存

共享内存就是将两个进程的两块虚拟内存，映射到同一块物理内存中，这样就实现了几乎无延迟的通信，但是共享内存有个问题，就是它的读写并不是原子操作，进程间会存在互斥或者不同步的情况，所以一般会和信号量共同使用。

共享内存的接口介绍：

```cpp
#include <sys/ipc.h>
#include <sys/shm.h>
```



1. `shmget`

```cpp
int shmget(key_t key,size_t size,int shmflg);
功能：用来创建共享内存

key：是这个共享内存段的名字
size：共享内存的大小
shmflg:相当于权限位（如0666）
返回值是共享内存段的标识码shmid,
例如：shmid = shmget(0x1111, 128, 0666);
//创建共享内存 , 相当于打开打开文件
//若共享内存存在 则使用 fopen()
//若共享内存 不存在 则报错 -1

shmid = shmget(0x1111, 128, 0666 | IPC_CREAT);
//创建共享内存 , 相当于打开打开文件
//若共享内存存在 则使用 fopen()
//若共享内存 不存在 则创建

shmid = shmget(0x1111, 128, 0666 | IPC_CREAT | IPC_EXCL);
//创建共享内存 , 相当于打开文件
//若共享内存存在 则报错
//若共享内存 不存在 则创建
//作用 IPC_EXCL判断存在不存在的标志 避免已经存在的文件 被覆盖
```

2. `shmat()`

```cpp
void *shmat(int shmid, const void *shmaddr, int shmflg);
功能：将共享内存段连接到进程地址空间

shmaddr:指定连接的地址，因为内存地址是段页式管理，所以有可能传入的地址并不就是那一页的开头位置，所以传入一个地址，传出的仍然是一个地址，传出的是具体开始存储的地址。所以我们通常传入NULL，让编译器直接分配个合适的位置给我们。

shmflg:它的两个取值可能是SHM_RND和SHM_RDONLY.

例： void *p = shmat(shmid, NULL, 0);

返回值：成功返回一个指针，指向共享内存第一个节，失败返回-1；
```

3. `shmdt()`

```cpp
int shmdt(const void *shmaddr);
功能：将共享内存段与当前进程脱离，但并不等于删除共享内存段
```

4. `shmctl()`

```cpp
 int shmctl(int shmid,int cmd,struct shmid_ds *buf);
功能：用于控制共享内存

cmd:将要采取的动作

1，IPC_STAT 把shmid_ds结构中的数据设置为共享内存的当前关联值

2，IPC_SET 在进程有足够权限的前提下，把共享内存的当前关联值设置为shmid_ds数据结构中给出的值

3，IPC_RMID 删除共享内存段

buf: 指向一个保存着共享内存的模式状态和访问权限的数据结构

例： shmctl(shmid, IPC_RMID, NULL);

//删除共享内存

若想要把旧的共享内存里面的内容保存下来，则传入一个地址，用来完成保存的功能
```







# 通信相关



## IIC通信

IIC 通信是一种区分主从设备的双线同步通信方式，分为SDA和SCL两根线，这两根线需要接上拉电阻，使其空闲情况下保持高电平状态。只有主机才可以发送起始和结束信号。

IIC通信最主要的三个信号分别是：

1. 起始信号：SCL处于高电平时，拉低SDA就是起始信号
2. 结束信号：SCL处于高电平时，拉高SDA就是结束信号
3. 应答信号：当将八位数据或命令发出后，会将SDA释放，等待接收方的应答，如果接收方收到数据则会将SCL处于低电平时把SDA拉低，成为低电平，表示接收到数据，如果没接收到则不会回复，此时发送端则会停止发送。如果接收器是主控器，则在它收到最后一个字节后，发送一个NACK信号，以通知被控发送器结束数据发送，并释放SDA线，以便主控接收器发送一个停止信号P。

除此之外IIC的报文还会用到**七位地址**和**一位读写位**，是紧接着起始信号发送的，读写位0代表写，1代表读。除去起始信号就已经8位了所以这后面就需要跟着一个应答位。



## UART通信

UART通信实际上只规定了传输层的一个协议，它并没有对数据链路层、物理层和应用层做处规定，着也就延申出了485、232、422这些通信方式，实际上它们的协议层都是串口通信，我们先来说一说串口通信的协议内容。

UART通信是一种全双工的异步通信方式，需要通信双方设置同样的波特率才能正常进行通信，这个波特率就是指一秒所能传输的位(bit)个数。UART通信要想实现双方的全双工通信必须使用至少三根线，分别是TX、RX和GND。

当开始传输数据时需要将信号线拉到低电平，表示数据传输开始，然后连续发送设定的位数，之后进行奇偶校验，也可以设置没有奇偶校验，然后发送停止位，可以设置是一个始终周期1.5个和2个。UART通信每次最多只能发送9个bit，基本的配置中可以设置每次发送的数据是9bit。

**奇偶校验：**包括奇偶校验位和前面的八位数据高电平（1）数量的总和是奇数还是偶数，如果是偶校验，但是数据中只有奇数个高电平(1)则在奇偶校验位加一个高电平(1)使其总数位偶数个。

接下来说下串口通信数据链路层的区别：

| 名称 | 区别                                                         |
| ---- | ------------------------------------------------------------ |
| 232  | 采用+5V~+15V表示0，-5V~-15V表示1，一对一收发，全双工，最远传输距离15M |
| TTL  | 输出低电平小于0.8V，高电平大于2.4V，输入低电平小于1.2V，高电平大于2.0V |
| 485  | 采用差分通信方式，高电平电压差位+2V~+6V，低电平位-2V~-6V，半双工，传输距离可达一公里以上，支持一主机多从机，并且从机之间也可通信，最多32个从机 |
| 422  | 采用差分通信方式，高电平电压差位+2V~+6V，低电平位-2V~-6V，全双工(需要四根线，两根发送，两根接收)，传输距离可达一公里以上，支持一主机多从机，但从机之间不可通信。 |







## SPI通信



SPI 使用cs选择从设备，根据从设备的定义决定给低电平选择还是高电平选择。

SPI 极性位0    空闲是就是低电平 

相位为0时 每个周期的第一个时钟沿采样，1时第二个时钟沿采样



## CAN通信

CAN总线一共规定了五种类型的帧，帧也称为报文。

| 帧                          | 帧用                                           |
| --------------------------- | ---------------------------------------------- |
| 数据帧（Data Frame）        | 用于发送单元想接收单元传输数据的帧             |
| 远程帧（Remote Frame）      | 用于接收单元向具有相同ID的发送单元请求数据的帧 |
| 错误帧（Error Frame）       | 用于当检测出错误时，向其他单元通知错误的帧     |
| 超载帧（Overload Frame）    | 用于接收单元通知其尚未做好接收准备的帧         |
| 帧间隔（Inter Frame Space） | 用于将数据帧及遥控帧与前面的帧分开来的帧       |



先说下数据帧，它也是最常用的一种，但也最复杂。

CAN总线协议可以分为，**帧起始、仲裁段、控制段、数据段、CRC段、ACK段和帧结束**。共七段。

它以**一个显性位**（逻辑0）开始，以**七个连续的隐性位**（逻辑1）结束。数据帧分为**标准格式**和**拓展格式**。

**标准帧中：**

* **仲裁段：**

  * 在一位的起始帧后面紧跟着十二位的仲裁段，在仲裁段中前11位表示帧的ID，

  * 最后一位是**远程发送请求位(RTR)位**，当需要从另一个节点请求信息时此位为显性（逻辑0）。

* **控制段：**
  * 控制段共占用6位，
  
  * 第一位是**IDE位**，它标志着该帧是否为拓展帧，在标准帧中为显性。
  
  * 第二位是保留位，默认为显性位。
  
  * 后四位是**DLC位**，它标志着，数据帧所发送的字节数，最多位8字节。
  
* **数据段：**
  * 顾名思义，该段用来传输数据。

* **CRC段：**
  * 这一段公16位用来进行对数据进行校验，校验的方式就是CRC校验,在数据帧中，CRC的校验范围为，帧起始+仲裁端+控制段+数据段。
  
  * 前15位是CRC校验码，最后一位是CRC界定符DEL，为隐形，主要作用是吧CRC校验码和后面的ACK段隔开。
  
* **ACK段：**
  * ACK段共有两位，第一位是ACK位第二位的界定符DEL。DEL界定符为隐形位。
  
  * ACK在发送节点发送时，为隐性位。当接收节点正确接收到报文时，对其用显性位覆盖。DEL界定符同样为隐性位，用于隔开。
  
* **帧结束段（End-of-Frame, EOF）：**
  * 帧结束段由发送端发送7个隐性位表示结束。

**拓展帧中：**

拓展帧中只有仲裁段和控制段有区别，其他段都是一样的。

在拓展帧中仲裁段拥有32位，相对于标准帧多了20位，这20位插在了标准ID和**RTR位**之间，

这20位中有18位是拓展帧的ID与标准帧用途一样。不多说了。

在标准帧的11位之后有一个SRR位，该位为隐性，这位有两个作用，一是让标准帧和拓展帧的格式一致，二是让标准帧的优先级高于拓展帧。

接下来是一位IDE位，这样做就可以使标准帧和拓展帧前半部分都相同，并且它可以保证标准遥控帧的优先级高于扩展遥控帧。

在仲裁段的最后，就是RTR位，用于确定是不是远程帧。

在控制段代替IDE位的是一个保留位，默认位显性位。



### CAN总线的时序问题

Time Quantum 时间份额TQ ：CAN控制器工作的最小时间单位，通常对系统时钟分频得到。

波特率：单位时间内（1s）传输的数据位，公式：1/位时间。举个栗子，系统时钟频率36MHz，预分频因子为4，则CAN时钟频率9MHz，则Tq=1/9M。假设一个CAN位包含10个Tq，则一个位周期T=10Tq，从而波特率为1/T=0.9MHz.

为了实现位同步，CAN协议把每一位的时序分解成下图所示的四段。这四段的长度加起来即为一个CAN数据位的长度。一个完整的位由8-25个Tq组成。	

- 同步端（SS，Synchronization Segment）

一个位的输出从同步段开始。若总线的跳变沿被包含在SS段的范围之内，则表示节点与总线的时序同步。节点与总线同步时，采样点采集到的总线电平即可被确定为该电平的电位。SS段的大小为1Tq.

- ·传播段（PTS，Propagation Time Segment）

用于补偿信号在网络和节点传播的物理延时时间，是总线上输入比较器延时和输出驱动器延时总和的两倍。通常1-8Tq

- ·相位缓冲段1（PBS1， Phase Buffer Segment 1）

主要用于补偿边沿阶段的误差，其时间长度在重新同步时可以加长。初始大小1-8Tq.

- 相位缓冲段2（PBS2，Phase Buffer Segment 2）

也是用于补偿边沿阶段的误差，其时间长度在重新同步时可以缩短。初始大小2-8Tq.



### CAN总线仲裁

CAN总线的仲裁方式是使用仲裁段进行仲裁：

* 在总线空闲时，最先开始发送报文的节点获得发送权，且发送权不会会被优先级高的节点抢占。
* 在多个节点同时访问总线时，CAN采用非破坏式的、逐位仲裁的的方式决定那个节点使用总线，各个发送节点从仲裁段的第一位开始进行仲裁，连续输出显性电平(0)最多的节点获得优先权。总而言之就是**看显性位的数量**。

### 位填充机制

CAN收发器会在每个连续的**五个相同信号**后面补充一个补码，原因有三：

1. CAN网络同步需要足够多的上升沿。
2. 确保数据帧不会被当作错误帧，因为错误帧是由六个连续的显性或隐形位组成。
3. 确保正确识别帧结束标志（7个连续隐性位）。

### 关于ACK信号

ACK信号只确保总线上有设备接收到了，即确保消息正确发送出去了，并不能确保目标设备接收到了消息，因为ACK是在CAN报文滤波的之前进行的。

### CAN的五种错误检测

CAN总线规定了五种错误检测方法，三种位于报文层，两种位于位流层。

在报文层中：

1. CRC校验错误：CRC校验出现错误。
2. ACK：当报文被接收方正确接收时，接收方会将ACK段的SLOT位置为显性，以告知发送节点数据正常接收。如果没有接收方将该位置为显性，就会重发。
3. 固性位校验：CAN会对报文中一定为隐性位的段进行检查，如果出现显性则该帧出现错误。这些段包括SOF、EOF、ACK界定符和CRC界定符。

在位流层中：

1. 会检测发送到总线上的每一个数据位，如何发送位和总线上的位不相同时，则会产生错误，该机制不会检测仲裁段，因为这部分会被高优先级设备覆写。
2. 位填充校验：如果出现六个相同的逻辑，则出现错误。

### CAN的远程帧

CAN的远程帧与数据帧的区别在于没有数据段，并且RTR位为隐性。

### CAN的主动错误帧

当错误主动节点检测到一个总线错误时，这个节点将产生一个主动错误标志来中断当前的报文发送。主动错误标志由 6 个连续的显性位构成。这种位序列主动打破了位填充规则。所有其他节点在识别到所生成的位填充错误后，会自行产生错误帧，称为错误反射标志。

错误标志字段因此包含 **6 到 12 个连续显性位 （由 1 个或多个节点产生）**。**错误定界字段 （8 个隐性位）**为错误帧划上句号。在错误帧发送完毕后，总线主动恢复正常状态，被中断的节点会尝试重新发送被中止的报文。

### CAN的过载帧

过载帧与主动错误帧具有相同的格式。

但是，过载帧只能在帧间间隔产生，因此可通过这种方式区分过载帧和错误帧 （错误帧是在帧传输时发出的）。过载帧由两个字段组成，即过载标志和随后的过载定界符。过载标志由 6 个显性位和紧随其后的其他节点产生的过载标志构成 （而主动错误标志最多包含 12个显性位）。过载定界符包含 8 个隐性位。节点在两种情况下会产生过载帧：

1）节点在帧间间隔检测到非法显性位。在 IFS 的第三位期间检测到显性位除外。这种情况下，接收器会把它看作一个 SOF 信号。
2）由于内部原因，节点尚无法开始接收下一条报文。节点最多可产生两条连续的过载帧来延迟下一条报文的发送。





## LIN 总线

简单看了下LIN总线，现在对LIN总线的理解就是，它是一种采取轮询方式进行通信的总线，和其他的总线区别很大，它不能算是标准意义上的异步通信，因为从机会通过主机的同步段确定通信的频率，这样做的好处是它极大的降低了从机的成本，从机甚至不需要很稳定的晶振，。因为它最大只能挂载**16个设备**，使得采用轮询的方式进行通信是可行的，主机不断的向每个从机轮流发送信号，从机不能主动向总线发送信号，只能等待主机的信号，收到主机的信号后如果有需要发送的数据，它才能发送数据，

### LIN的帧结构

LIN总线的帧结构相对简单，它的一帧主要有亮部分组成，分别是**报文头(Header)**和**报文响应(Response)**，在报文头和报文响应之间，有一个最小空间为0的**帧内空间分隔**。

#### 报文头

报文头由**同步间隔场**，**同步场**、和**PID场**，三部分组成。

**同步间隔场**：同步间隔场用于表示一帧报文的开始，主节点发出的间隔信号至少有13个显性位，间隔界定符至少有一个隐性位。同时从节点需要连续检测到11个先行为才认为是间隔信号。

**同步场**：同步场位1字节内容固定位0x55，该部分内容用于同步数据，确保所有的从节点与主节点使用相同的波特率发送和接受数据。

**PID场**:这部分由6位ID位和两位P位组成。其中两位P位为奇偶校验位，对前面的ID位进行奇偶校验。其中P0为对ID0、ID1、ID2、ID4的奇校验，P1为对ID1、ID3、ID4、ID5的偶校验。**ID的范围是0~0x3F**。值得一提的是ID中第四位和第五位和数据长度相关，值为01时是4字节，11时是8字节。但在十季应用中大多数会使用8字节，这也是为什么LIN最多只能挂载16个设备，因为在一个字节的PID场中由两个字节用来做**奇偶校验**，两个字节用来做**长度控制位**。

对于PID场，60(0X3C)和61(0x3D)这两个ID 需要用于诊断命令。62(0x3E)和62(0x3F)作为预留。

```
ID0 ID1 ID2 ID3 ID4 ID5 P0 P1
```



#### 报文响应

报文响应由**2/4/8个字节的数据场**、**校验和场**组成。

**数据场**：数据场中每个字节线传输的是最低位。即如果一个信号长度超过了一个字节，采用低位在前的方式发送（小端）。

**校验和场**：校验和场是数据场所有字节的和的反码，所有数据字节的和的补码与校验和字节相加所得的和必须是0xFF。





# 面经收集

### const的变量保存在哪里和static是否一样

const全局变量保存在只读数据段，编译初期建立，程序结束时释放

const局部变量保存在栈中，代码块结束时释放，在C语言中可以用指针对const局部变量进行修改，而不能用指针修改const全局变量。因为const全局变量储存在只读数据段。

在C++中，const不是必须创建内存空间，而在C中const必须要有一块内存空间。

在C++中，是否为const全局变量分配空间，取决于这个const变量的用途，如果是充当着一个值替换（即将一个变量名替换为一个值），那么就不分配内存空间，不过当这个const全局变量取地址或者使用extern时，就会被分配内存，储存在只读数据段，也是不能修改的。

c中const默认为外部连接，c++中const默认为内部连接.当c语言两个文件中都有const int a的时候，编译器会报重定义的错误。而在c++中，则不会，因为c++中的const默认是内部连接的。如果想让c++中的const具有外部连接，必须显示声明为: extern const int a = 10。

**指针常量和常量指针**

```cpp
int a =10;
int * const p=&a;
//  指针 常量    不能修改指针的指向  指针是常量
指针常量还有下面的写法
int const * p=&a;
//同时 指针常量必须初始化，且指针常量可以指向空

const int * p=&a;
//常量    指针     不能修改被指向的值  指针指向的值是常量

```

在类中的const

常函数

常函数是指一个类的一个成员函数后面加了const的函数，实际上它是给自己的this指针加了一个const，让this指针指向的值也无法修改了，**在常函数中不能修改成员变量**，如果在成员变量声明时加了**`mutable`关键字，那么在常函数中也可以对其进行修改**

```cpp
int fun(int a) const{} //声明一个常函数
```





**常对象**

常对象就是在声明时在对象类型的前面加上const，那么指个对象就不能调用非常函数，因为非常函数有可能会修改类内的变量，我们既然定义成了常对象，那么我们就是不希望它里面的属性被修改，**常对象只能调用常函数**

```cpp
class exp{
//.....    
};
const exp a;//声明一个常对象。
```



**静态变量static**

**面向过程时**

静态变量static被储存在静态变量/全局变量区，默认被初始化为0，编译阶段就分配内存，一直到程序结束才被销毁，静态变量在面向过程时还分为局部静态变量和**全局静态变量：**

全局静态变量和全局变量很像，区别是全局静态变量只有在当前文件内可以使用，而到了另外一个文件它就是不可见的。

**局部静态变量：**

局部静态变量主要体现在它的局域性，它的作用域只在它被初始化的块内，并且只会在第一次被使用时初始化，之后再次运行到这部分不会再初始化了，因为它被储存在全局数据区，而不是存在栈中，所以在它的代码段运行结束后不会随着栈区其他局部变量被清除，而是一直存在到程序结束。

**静态函数：**

静态函数和全局静态变量一样，对其他文件不可见，其他文件中可以有同名的函数名，而不会发生冲突。

**面向对象时**

当静态变量出现在类中，需要在类内声明，在类外初始化，用作用域符号对其进行访问，并且该类的所有对象都使用这一个静态变量，内存在编译阶段就分配，程序结束被销毁，并且在类中声明的静态变量，也存在访问权限，在`private`中声明的静态变量，在类外也不能访问。

```cpp
class exp{
public:
    static int m_a;
private:
    static int m_b;
};
exp a;
cout<<a.m_b<<endl;//错误 私有变量不能访问。
//两种访问方式

// 1) 通过对象进行访问
cout<<a.m_a<<endl;
// 2) 通过类名进行访问
cout<<exp::m_a<<endl;
```

**静态成员函数**

静态成员函数和静态成员变量一样，所有的成员都共用一个函数，需要注意的是，**静态成员函数只能访问静态成员变量和静态成员函数**

```cpp
class exp{
public:
    static int fun(){};
}
//调用方式和访问成员变量一样，可以通过对象进行访问，也可以通过类名进行访问。
```









#### 实时系统是如何保证强实时性的

1、可抢占式的内核

2、几乎每个系统操作的时间可确定性。

3、可预测性（确定性）

#### 中断的处理过程

~~~mermaid
graph LR
请求中断-->中断响应-->关闭中断-->保护断点-->中断源识别-->保护现场-->中断服务-->恢复现场-->中断返回
~~~

在STM32的中断由NVIC（嵌套向量中断控制器）来完成，中断都是由NVIC来进行管理的，中断发生时会先发送给NVIC，然后再发送给处理器，处理器响应后保护断点，识别中断源、保护现场等等一系列操作。STM32是通过招中断向量表，通过中断向量表的指针来找到中断服务函数所在的位置的。

在ARMv7架构中就不支持中断的嵌套了，同时这一代的ARM架构中断处理也不是通过向量表寻址的方式进行，而是通过指令的方式，由b指令直接跳转。它产生中断后的大致流程如下：

ARM产生异常后的动作（自动完成）

1. 备份CPSR（程序状态寄存器）中的内容到SPSR
2. 修改CPSR的值
   1. 禁止相应中断
   2. 进入相应的异常模式
   3. 进入ARM状态
3. 保存放回地址到LR
4. 转跳到异常向量表中对应的位置

ARM异常返回动作（自己编写）

1. 将SPSR的值恢复到CPSR，使处理器恢复之前的状态
2. 将LR的值恢复到PC，是程序跳回呗打断的地址继续执行

这部分之所以需要自己编写，是因为不同的操作系统可能对这部分要求不一样，部分的操作系统在处理完中断后需要再确认就绪队列的情况，查看是否需要切换到新的任务或者进程中。

Linux的中断机制分文上下半部分，主要目的是为了避免在中断中消耗过多时间，上半部分在中断中完成，下半部分根据紧急情况做一定的推迟。因为Linux中断是不支持嵌套的，所以要尽量缩短在中断中的时间，同时中断可以任意抢占进程的CPU时间，那么如果在中断中花费太多的时间，会导致进程被饿死。



#### uCOS的任务调度方法

根据优先级进行调度，在uCOS-III中还支持了同优先级任务的时间片轮转调度，调度发生在每个时间片用完后或某些事件发生后，会由任务调度函数找到当前就绪链表中最高优先级的任务，并做任务上下文的切换。

#### 死锁产生的条件

1. 互斥条件：资源是互斥使用的
2. 不剥夺条件：进程只能由自己释放
3. 请求和保持：已获得资源的同时，还在请求另外一个资源
4. 循环等待：存在一个循环等待链



#### 实时系统和Linux系统的区别

实时系统具有确定性，而Linux并不具有100%的确定性，Linux是分时操作系统

#### 单片机寄存器的底层原理





#### 静态链接和动态链接的应用场景



#### FreeRTOS任务管理



#### FreeRTOS的任务间通信还有uCOS的

uCOS的任务间通信主要有四种方式，分别是**互斥信号量** 、**信号量**、**消息队列**和**事件标志组**，其中互斥信号量是特殊的信号量，除此之外uCOS-III还支持**同时等待多个内核对象**，但是同时等待多个内核对象只支持同时等待多个信号量和消息队列，而不支持事件标志组和互斥信号量。

每个信号量、消息队列，都有它们自己的结构，它们的结构中标记了当前正在等待的任务，如果自己有可用的内容，就会触发调度器，来进行任务调度。

**信号量：**

信号量又可以分为计数信号量和二值信号量：

1. 二值信号量：

二值信号量只有0和1两个值，当这个信号量是1时，那么它可以被请求使用，但是一旦被请求使用了，那么这个信号量就会变成0，若此时其他任务再请求该信号量，那么它将会被阻塞，在请求信号量时可以设置一个时间，若到了时间还没能请求到信号量，那么也会被返回，只不过会被标记为超时返回，而不是获取到了信号量。

2. 计数信号量：

计数信号量和二值信号量很像，只不过它的初始值可以设置，每次被请求后会被减1，也就是说二值信号量同时只能被一个任务使用，而计数信号量能被它设置的个数的任务使用。

**互斥信号量：**

互斥信号量是一个特殊的二值信号量，之所以特殊，是因为它具有优先级继承的能力，可以解决优先级反转的问题，优先级反转是什么就暂不赘述了，当高优先级的任务请求一个mutex，而这个mutex被低优先级的任务占用，那么为了避免优先级反转情况的发生，mutex会让低优先级的任务，暂时继承高优先级任务的优先级，将低优先级的任务优先级临时提升到和高优先级任务同等优先级，而在它释放mutex后再将它原本的优先级恢复，这就是mutex的优先级继承机制。

**消息队列：**

消息队列，实际上就是一个可以储存多个消息的队列，队列遵从FIFO先进先出的顺序，但也可以LIFO后进先出，比如在中断中发送的紧急任务就可以设置成LIFO，从而让任务优先处理。消息队列中存放的是**指针**，一般指向一个地址空间，同时还会有该**消息的大小**和发布时的**时间戳**，方便请求消息的任务判断该消息是否还有处理的价值。消息队列可以多任务发送，多任务请求，当有多任务请求时，由最高优先级的任务最先获取消息，发送方也可以发送广播消息，让所有等待的任务都接收到消息。

任务可以对消息队列执行，创建、删除、清空、等待、取消等待和发送。而中断只能供发送消息。

**事件标志组：**

事件标志组可以处理多任务的同步问题，它主要有两种同步方式，分别是**或同步**和**与同步**，当任意一个事件发生任务都会被同步的是或同步，必须所有事件发生才会被同步的叫与同步。

除此之外，信号量和消息队列都有任务内嵌的信号量和消息队列，与普通的信号量和消息队列的差别是，它们处于任务内部，不需要被创建，可以直接被使用，但同时也不能删除。



#### 如何判断有限长链表是否有环

利用快慢指针法，快指针每次走两格，慢指针每次走一格，如果有环，那么快指针一定能追上慢指针，如果需要判断环的入口，那么只需要在链表的开头和快慢指针相遇的点同时放出一个每次走一格的指针，它们相遇的地方就是链表的入口。



#### 程序必须从main函数开始吗

程序不是必须从main函数开始，只不过编译器默认在`_start()`之后调用main函数而已，我们可以改变`_start()`函数让它不调用main函数，而是调用其他函数，除此之外，我们还可以通过用函数给全局变量赋值的方式，还有实例化全局对象等方法来实现让一些代码在main函数之前运行。此外我们可以在函数定义前面加上`__attribute__((constructor))`和`__attribute__((destructor))`让函数分别运行在main函数之前和main函数之后。

#### main前发生了什么

在main函数之前分了两部分，一部分是系统的操作，另一部分是C/C++程序自己的操作。

**系统的操作**

想要执行C程序，就需要在`fork`后调用`exec`系统调用，在调用 main 前先调用一个特殊的启动例程。可执行文件将此启动例程指定为程序的起始地址。启动例程从内核取得命令行参数和环境变量值。

1. 简而言之，系统会为你设置栈，并且将`argc，argv`和`envp`压入栈中。文件描述符0，1和2`（stdin, stdout和stderr）`保留shell之前的设置。
2. 加载器会帮你完成重定位，调用你设置的预初始化函数。
3. 当所有搞定之后，控制权会传递给`_start()`，即程序的入口函数

**C程序的操作**

1. 入口函数对运行库和程序运行环镜进行初始化，包括 堆、I/O、线程、全局变量构造等等。
2. 入口函数完成初始化后，调用 main 函数，正式开始执行程序主体部分。

原文如下：

set up initial stack pointer 

initialize static and global data 

zero out uninitialized data 

run global constructors

Some of this comes with the runtime library's crt0.o file or its __start() function. Some of it you need to do yourself.



#### sizeof详解



#### 各种排序



#### 多线程的同步方法

（1）通过条件变量进行线程间的通信

（2）通过标志位来通知线程间的通信

（3）通过std::furture来进行线程间的通信

#### 在1G内存的计算机中能不能malloc(1.2G)



#### malloc的底层

malloc的底层实现主要由两个系统中断实现分别是`brk`和`mmap`，其中小于128k的内存申请由`brk`来实现，`brk`的实现方法就是推高堆的堆顶指针`_edata_`，当申请的内存大于128K时，就会使用`mmap`系统调用，`mmap`会从堆和栈之间找一块空闲的地址来开辟申请的内存。需要注意的时`brk`申请的内存需要在高地址内存释放完之后低地址的才能释放，而`mmap`可以随时单独释放。



#### 什么时候会产生野指针

1、创建指针时没有对指针进行初始化，导致指针指向一个随机的位置；
2、释放指针指向的内存后没有置空，从而指向垃圾内存；
3、在超越变量作用域下使用指针，如：在栈内存被释放之后，指向栈内存的指针会指向垃圾内存；

#### 系统调用是如何实现的

1. 用中断门实现系统调用，通过0x80中断作为系统调用的入口
2. 在IDT中安装0x80号中断对应的描述符，在该描述符中注册系统调用对应的中断处理例程
3. 建立系统调用子功能表，利用`eax`寄存器中的子功能号在该表中索引相应的处理函数
4. 用宏实现用户空间系统调用接口`_syscall`，最大只支持3个参数，`ebx`保存第一个参数，`ecx`保存第二个参数，`edx`保存第三个参数

#### 什么是系统调用

程序的运行分为两个状态，一个是用户态一个是内核态，用户态下凡是于系统级别资源有关的操作都不能在用户态进行，必须由系统代为操作，而系统调用就是系统提供给程序的接口，程序可以通过调用系统调用，来对敏感资源进行访问和修改。**系统调用主要可以分为四类：**

1. **设备管理**：完成设备的请求/释放以及设备的启动
2. **文件管理**：完成文件的读写、删除、创建等功能
3. **进程控制**：完成进程的创建、撤销、阻塞以及唤醒等功能
4. **内存管理**：完成内存的分配、回收以及获取作业占用内存区大小和地址等功能

#### 为什么C++可以函数重载，而C不行

因为C语言在汇编阶段函数映射到符号表时使用的就只有函数名，而C++在映射到函数表的时候除了函数名还有函数类型等信息，所以C++可以实现函数重载，而C语言不行，

#### 什么是虚函数表

虚函数表是一个指针数组，里面存放着虚函数被重写后所在的地址，只要类中有一个虚函数，那么这个类就会有一个指向虚函数表的指针，当然如果有多个虚函数，也只有一个虚函数表指针，只占用一个指针的空间。虚函数表中的指针指向亲缘关系中最近被重写的虚函数。



#### **arm寄存器组有哪些，13,14,15号寄存器的作用，PC寄存器的作用；**

ARM架构的处理器共有37各寄存器，分别用于六种模式 USR、FIQ、Supervisor、Abort、IRQ、Undefined，其中正常模式下有R0-R15 + CPSR17个寄存器，除了FIQ的四个模式分别有三个寄存器分别是LR、SP和CPSR寄存器这是12个寄存器，而FIQ除了LP、SP和CPSR还有五个通用寄存器，是8个，加起来一共37个

它们分别是SP寄存器LR寄存器和PC寄存器，其中SP寄存器指向下一个堆栈地址，PC寄存器是下一个要执行的命令，LR寄存器是函数的返回地址。

除此之外还有C/APSR寄存器和SPSR寄存器，在USR下是没有SPSR的，因为USR是正常模式也就是当前的状态，而SPSR的储存上一次正常的状态，用于出现异常时能返回到正常状态。



#### **ARP通信**

ARP通信是用于在局域网范围内利用IP地址，通过广播的方式请求目标IP的MAC地址的一种通信协议，ARP请求中包含着本机的IP和MAC，还有目标的IP和一个全为0的MAC地址。这个IP地址如果是跟主机同一网段，那么它就直接是目标地址的IP地址，但如果我们要和外网通信，目标IP地址肯定和我们的主机IP不是一个网段，那么网关地址就起到作用了，ARP发送的目标IP地址就算网关地址，我们找到网关的MAC地址之后，再给它发送我们要发送的数据就可以了，后续就交给强大的网关就可以了。

#### **NAT**

NAT的出现是为了解决当前IPv4地址紧缺的问题的，我们可以再一个较小的区域内搭建一个NAT路由器，比如学校或公司内，这样我们就可以让NAT之下的所有设备拥有私有IP地址，而NAT路由器拥有公有IP就可以了，怎么实现的呢，我们可以在NAT路由器的公网IP后面加上端口号，对公网每个IP端口和私网的每个IP和端口做一一的映射，这样就可以环境IP不够的情况了。

#### **路由**

知道目标的IP地址之后，我们还需要经过复杂的网络来寻找到目标IP到底在哪里，而这一部分就需要交给路由来做了，路由器会根据路由表来确定应该将报文转发到哪里，路由器会用目标的IP地址和路由表上面的IP地址做匹配，匹配相似度最长的，再转发给目标路由器，这样一步一步进行转发，直到达到目的地。

#### **TCP协议**

TCP协议在TPC/IP协议的第三层，传输层，在它之上有应用层，它之下是IP的网络层和数据链路层。

TCP协议的标准头部为20个字节，此外还有长度可变的选项，其中有2字节**源端口号**、2字节**目标端口号**、4字节**序列号**、4字节**确认应答号**、4位**首部长度**、6位**保留**、**URG、ACK、PSH、RST、SYN、FIN**六个**控制位**各一位，两字节**窗口大小**、两字节**校验和**、两字节**紧急指针**，再后面就是选项和数据了。

**序列号：**在建立链接时由计算机随机生成的数作为初始值，通过SYN包发送给接收端主机，没发送一次数据，就*累加*一次*该数据字节数*的大小。用来解决网络包乱序问题。

**确认应答号：**指下一次期望接收到的数据的序列号，发送端收到这个确认应答以后可以认为这个序号以前的数据都已经被正常接收。用来解决丢包的问题。

**控制位：**

- *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
- *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
- *SYN*：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。

**三次握手**

我们这里的三次握手就不单纯的说说链接过程了，我们把socket网络编程也加进来一起说。

首先，由服务器先调用`socket`函数获取socket的描述符，然后如果有需要的话会对socket进行一些配置，然后建立一个结构体，用于存放要绑定的ip地址和端口号，然后用`bind`函数将描述符和端口号进行绑定，然后调用`listen`函数，输入文件描述符进行监听，并设置允许链接的最大数量。客户端也需要调用socket函数，获取socket的描述符，再创建一个结构体`sockaddr_in`来储存目标IP和端口号，再调用`connect`函数，输入文件描述符、结构体和结构体长度，从这里开始TCP链接就要开始建立了。

当我们调用connect函数时，客户端首先会向服务器发送一个SYN位为1的包，也叫SYN包，其中的序列号是随机生成的，发送完SYN包后，客户端转为`SYN_SENT`状态，因为当前服务器处于`LISTEN`状态，所以服务器可以接收到这个请求，如果服务器当前的状态可以进行链接，那么它回调用accept函数，来接受这个连接，因为这条消息是回应SYN包所以这条消息将SYN和ACK都置为1，并且将客户端的序列号+1，作为确认应答号发送，自己再重新生成一个随机的序列号作为序列号发送给客户端，这条报文发送后，服务器变为`SYN_RCVD`状态，当客户端收到了服务器发来的确认连接信息，还需要再发送给服务器一个ACK包，该包ACK位为1，确认应答号为服务器发过来的序列号+1，并且这条报文是可以携带数据的，发送完本条报文客户端变为`ESTABLISHED`状态，表示可靠连接已建立，当服务器接收到报文后也会变为`ESTABLISHED`状态，至此TCP连接建立完成。



**四次挥手**

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务器收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

你可以看到，每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。

这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**



## C++的内存分区

**1，内存分配的类型：**

在C/C++中[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)分为5个区，分别为**栈区、堆区、全局/静态存储区、常量存储区、代码区。**

**静态内存分配:**编译时分配。包括:全局、静态全局、静态局部三种变量。

**动态内存分配:**运行时分配。包括:栈(stack): 局部变量。堆(heap): c语言中用到的变量被动态的分配在内存中。malloc或calloc、realloc、free函数)

**2.变量的内存分配：**

**栈区（stack）：**指那些由编译器在需要的时候分配，不需要时自动清除的变量所在的储存区，如函数执行时，函数的形参以及函数内的局部变量分配在栈区，函数运行结束后，形参和局部变量去栈（自动释放）。栈内存分配运算内置与处理器的指令集中，效率高但是分配的内存空间有限。

**堆区（heap）：**指哪些由程序员手动分配释放的储存区，如果程序员不释放这块内存，内存将一直被占用，直到程序运行结束由系统自动收回，c语言中使用malloc，free申请和释放空间。

**静态储存区（static）：**全局变量和静态变量的储存是放在一块的，其中初始化的全局变量和静态变量在一个区域，这块空间当程序运行结束后由系统释放。

**常量储存区（const）：**常量字符串就是储存在这里的，如“ABC”字符串就储存在常量区，储存在常量区的只读不可写。const修饰的全局变量也储存在常量区，const修饰的局部变量依然在栈上。

**程序代码区：**存放源程序的二进制代码。













