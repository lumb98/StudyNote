# TCP/IP笔记

## TCP的socket编程一般步骤

**TCP:**
TCP编程的服务器端一般步骤是：
　　1、创建一个socket，用函数socket()；
　　2、设置socket属性，用函数setsockopt(); * 可选
　　3、绑定IP地址、端口等信息到socket上，用函数bind();
　　4、开启监听，用函数listen()；
　　5、接收客户端上来的连接，用函数accept()；
　　6、收发数据，用函数send()和recv()，或者read()和write();
　　7、关闭网络连接；
　　8、关闭监听；
**TCP编程的客户端一般步骤是：**
　　1、创建一个socket，用函数socket()；
　　2、*设置socket属性，用函数setsockopt();\* 可选*
　　3、*绑定IP地址、端口等信息到socket上，用函数bind();\* 可选(但不建议)容易引起端口号冲突*
　　4、设置要连接的对方的IP地址和端口等属性；
　　5、连接服务器，用函数connect()；
　　6、收发数据，用函数send()和recv()，或者read()和write();
　　7、关闭网络连接；
**UDP:**
与之对应的UDP编程步骤要简单许多，分别如下：
**UDP编程的服务器端一般步骤是：**
　　1、创建一个socket，用函数socket()；
　　2、设置socket属性，用函数setsockopt();* 可选
　　3、绑定IP地址、端口等信息到socket上，用函数bind();
　　4、循环接收数据，用函数recvfrom();
　　5、关闭网络连接；
**UDP编程的客户端一般步骤是：**
　　1、创建一个socket，用函数socket()；
　　2、设置socket属性，用函数setsockopt();* 可选
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选
　　4、设置对方的IP地址和端口等属性;
　　5、发送数据，用函数sendto();
　　6、关闭网络连接；

## TCP三次握手

1. 在客户端和服务器都完成了socket的创建，并且服务器已经绑定完要监听的端口之后，服务器就进入了listen状态，监听它所绑定的端口。
2. 此时客户端调用connect，这个时候三次握手就开始了，首先客户端会发送一个报文这个报文中SYN被置为1，也叫SYN包，序列号client_isn为随机生成的，表示请求连接，此时客户端就进入了SYN_SENT状态。
3. 此时因为服务器正处于监听状态，客户端的请求会被捕获，如果当前服务器有条件进行连接，则会调用accept，获取客户端的IP和端口信息，并创建客户端socket的文件描述符，此时服务器会返回一个报文，这个报文的ACK和SYN位都被置为1，确认应答号为client_isn+1，序列号为服务器随机初始化的server_isn，发送完这条报文后服务器进入SYN_RCVD状态。
4. 此时客户端正处于SYN_SENT状态等待服务器的回应，当收到服务器的回应后，将发送一条报文，这条报文ACK为1，确认应答号为server_isn+1，发送给完这条报文后，客户端进入established状态。
5. 服务器收到客户端的ACK后也进入established状态，连接建立成功。

## TCP四次挥手

1. 在通信完成后

<img src="C:\Users\WaitingForWind\OneDrive\学习相关\研究生\学习笔记\image-20220531154718490.png" alt="image-20220531154718490" style="zoom:80%;" />



## TCP/IP 的重传机制

TCP/IP的重传机制主要又四种，分别是，**超时重传**、**快速重传**、**SACK**和**Duplicate SACK(D-SACK)**。

### 超时重传

超时重传顾名思义，就是当报文发送过去之后，超过一段时间没有进行回复，就回触发的重传机制，而这个时间就是RTO（Retransmission Timeout 超时重传时间），还有一个名词是RTT（Round-Trip Time 往返时延），一般情况下RTO要比RTT略大，有一个计算公式，比较复杂，就不写在这里了。

### 快速重传

快速重传就是通过返回的ACK来判断哪一个报文没有发到，就重发该报文，但要注意，需要返回三个相同的ACK才会开始重传，假设连续发送以组报文分别为1、2、3、4、5，但是2号报文没有发送成功，那么ACK就会返回，1、2、2、2，其中后三个是由3、4、5号报文接收后的ACK返回的，那么现在收到了三个连续的ACK我们就会重传2号报文，当2号报文被成功收到后就会返回ACK6，当然假设我们这个时候只发到了5号报文，6号还没有发送呢，如果6号发送了就会返回ACK7，但这样做我们就不知道，收到的三个一样的报文是由哪几个报文返回的，也就不知道除了2号还有哪个需要重传。

### SACK（ Selective Acknowledgment 选择性确认）

这种方法需要在TCP头部选项字段里加入一个SACK，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据是没有收到的了，可以针对性的重传数据，假设我们发送100-800的包，ACK的返回与快速重传一致，但是假设200-299的报文发送失败了，在300-399的报文发送到后返回ACK200,SACK300-400，在300-399的报文发送到后返回ACK200,SACK300-500，以此类推。使用这个功能需要打开SACK功能，在Linux下可以通过`net.ipv4.tcp_sack`这个参数打开功能，在Linux2.4后默认会打开。

