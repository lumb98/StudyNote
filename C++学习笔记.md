`INT_MAX`是特殊字符表示INT类型的最大值。

## for循环 
不加等号时 不包含条件数字，加等号是包含条件数字。
不加等号时 运行次数等于条件数减初始数的绝对值，加等号时+1；

## ++ -- 递增递减运算符
在变量前时，是先进行递增运算，讲值赋完后，在进行其他运算
如
若`tmp2[0]`是1则会打印内容 因为`++`在变量前面，将递增后的值赋给变量之后才进行判断；

```cpp
if(++tmp2[0]==2)
        cout<<"++before==="<< tmp2[0]<<endl;
    return 0;
```

若`tmp2[0]`是1则不会打印任何东西 因为`++`在变量后面，本次判断完成后才将递增后的值赋给变量；
```cpp
if(tmp2[0]++==2)
        cout<<"++before==="<< tmp2[0]<<endl;
    return 0;
```

## 局部静态变量
在块内定义的变量的生命周期只存在于块内，若想让它从第一次被创建后一直存在可以设置局部静态变量，局部静态变量可以一直存在到程序终止。
定义局部静态对象的方式是在变量前加一个 ``static``


## 常量引用的作用
引用和指针的一个好处是它们比较迅速，实参把值传递给形参时，实际上是将值进行了拷贝，当我们不担心原本的参数被修改，或者我们不会修改它时，我们就可以使用引用和指针来作为形参，这样做如果传入的参数比较大时，我们就成功的避免了拷贝，增加了程序的运行效率，如果我们害怕不小心修改了输入的值，可以使用`const`来避免这种误修改，当我们要修改``const``时 编译器会报错，提醒我们修改了不该修改的值。这种操作就是我们常听到的**常量引用**                                                                                                                                

## 关于const
### const的层
说明一下顶层const啥的
```cpp
int i =5;
int * const p=&i; 
const int *cp =&i;
*cp=7;//错误，底层const不能改变i
*p=6;
```
这样就是 不可以给``p``赋值，但不影响``*p``。

### const 形参
```cpp
void fcn(const int i){/*能读取i但不能改写i*/}
void fcn(int i){/*出错了因为找个函数被重复定义了，*/}
```
可以看出 虽然两种看上去不一样，但是实际上编译器把他们看成是同一个函数了，也就是说，虽然`const`有作用，它并不是一个独立的类型。
实际上出错是因为函数的重载，函数的重载是根据输入和输出的区别来判断的，但是在上面的例子中，虽然形参表面上有所变化，但它**输入的类型并没有变化**

### 函数重载与const

```cpp
Record lookup(Account& n);		//新函数，作用于Account的引用
Record lookup(const Account& n);//新函数，作用于常量引用
Record lookup(Account* n);		//新函数，作用于指向Account的指针
Record lookup(const Account* n);//新函数，作用于指向常量的指针
Record lookup(Account n);		
Record lookup(const Account n);//错误，重复声明
Record lookup(Account* n);		
Record lookup(Account* const n);//错误，重复声明
```

注意它们的区别。`const`对象只能传递给`const`形参。


### 箭头运算符（->）和点运算符（.）
箭头运算符和点运算符类似，都可用于访问成员，其中，点运算符获取类对象的一个成员。箭头运算符与点运算符有关`prt->mem`和`(*ptr).mem`是等价的。
```cpp
string s1="a string".*p=&s1;
auto n=s1.size();
n=(*p).size();
n=p->size();
```
可以看出点运算符是面向对象的，而箭头运算符则可以用在指针上，<font color=red>`p.size()`</font>的表达方式是错误的，因为`p`是一个指针，而不是一个对象,此外<font color=red>`*p.size()`</font>这样的表达方式也是错误的，而<font color=green>`(*p).size()`</font>则是正确的，造成这一现象的主要原因是，解引用运算符`*`的优先级低于点运算符`.`所以加上括号才能正确的表达我们的意思。

### 返回数组指针

这里说一下``typedef``关键词，这个关键词就是给类型 重新设置一个名字，有些类型名非常长，就可以利用`typedef`关键词来重新赋予它一个名字，使其在使用时变得方便。

```cpp
typedef int arrT[10];//与下面的内容是等价的
using int arrT[10];//与上面的内容是等价的
arrT example{1,2,3,4,5,6,7,8,9,10};
for(int i=0;i<10;++i){
    cout<<example[i]<<endl;
}
```

以上代码可以打印`example`数组中的值，而`arrT`就代表了有十个`int`类型的数组。

这样做的一个应用就是我们可以方便的利用指针将数组返回。例如

```cpp
typedef int arrT[10];
arrT* func(int i);//func 函数返回一个指向含有十个int的数组的指针

arrT* func(int i){
    static int res;
    /*
    *
    *
    */
    return &res;
}
```

但需要注意的是，函数内返回的应该是要传送的数组的首**地址**，同时返回值也是地址，还有一点非常重要，我们不要忘了C++中变量的生命周期，我们声明返回的变量时一定要将其设置为静态变量，加上<font color=red>static</font>不然是没有办法返回这个指针的。~~目前能想到较好的使用方法是将函数的返回值设置成一个`arrT`类型的指针，然后再解引用就可以使用这个数组了。~~

```cpp
arrT* arrTprt;
arrTprt=func(1);
for(int i=0;i<10;++i){
    cout<<(*arrTprt)[i]<<endl;
}
```

上面的代码就可以打印出返回的数组的值了。

现在有了更好的办法，上面的办法有点蠢。

```cpp
for(int i=0;i<10;++i){
    cout<<(*func(1))[i]<<endl;
}
```

这回好多了，其实就是给函数返回的指针直接解指针，并且使用它。

那么如果我们不利于`typedef`关键词这个操作会变成什么样呢？

```cpp
int (*func(int i))[10];//函数的声明
int (*func(int i))[10]{//函数的定义
    /*。。。*/
}
```

这样可读性就降到非常低了。

在C++11中我们可以使用**尾置返回类型**

```cpp
auto func(int i)->int(*)[10];
```

如果我们知道函数返回的指针将指向哪个数组，我们就可以使用`decltype`关键字声明返回类型。

```cpp
int odd[]={1,3,5,7,9};
int even[]={0,2,4,6,8};
decltype(odd) *arrPtr(int i){
    return (i%2)? &odd:&even;
}
```



## 封装

### 什么是封装

C++ 的封装实际上就是它能将函数存入到类内部，这与结构体的区别就体现在了，类不仅能有属性，还能有行为。有了属性和行为就可以称之为一个对象了。

此外封装还能给属性和行为的访问权限加以控制，分为public、protected和private。

### `class`和`struct`的区别

在C++中二者的区别主要在于struct的默认权限为公共，而class的默认权限为私有。

而与C语言对比，struct中只能用于存放一些属性，而不能用于存放行为（函数），并且其中没有权限的区别，而这两点也就是C++所谓的封装。

### 构造函数和析构函数

构造函数和析构函数也是类中独有的，它们会分别在类实例化（创建一个对象）和被销毁时自动运行，被创建很容易理解，就是以这个类为类型创建了一个对象时，而销毁则有些需要说明，若对象被创建在栈区，那么它会在这个程序块执行完之后，随栈区一块被销毁，在栈区被销毁前会调用析构函数；若对象被创建在堆区，那么它就需要调用delete手动销毁，调用delete进行销毁时就会调用析构函数。

上述所说的构造函数和析构函数都不需要我们手动区执行，编译器会自动执行构造函数和析构函数，同时如果我们没有写析构函数和构造函数，编译器也会运行默认的空构造函数和空析构函数。

#### 构造函数

构造函数可以分为3类，无参构造函数、有参构造函数和拷贝构造函数，它们的形式分别如下：

```cpp
class temp{
public:
    temp(){
        //这是无参构造函数，如果花括号内什么也不写，那它也叫默认构造函数，就是在不写构造函数时编译器默认执行的那个
        
    }
    
    temp(int a){
        //这就是有参构造函数
    }
    
    temp(const temp &t1){
        //这是拷贝构造函数，注意入口参数必须要取引用并且常量化。
    }
};
```

实际上这三个函数都是函数重载的类型。

下面是三种构造函数的使用

```cpp
temp t1;//默认构造函数
//temp t1(); 这是错误的用法，会被编译器认为是一个函数的声明，声明了一个返回值为temp没有入口参数的函数。
temp t2(1);//有参构造函数
temp t3(t2);//拷贝构造函数
```

值得一提的是，在使用默认构造函数时有些时候我们可能会加一个括号`temp t1();`，这样的作法是不对的，这种写法是函数的声明。

其中构造函数还有三种调用类型，分别是括号法、显示法和隐式转换法。

上面的示例就是使用了括号法，下面我们演示显示法和隐式转换法。

显示法：

```cpp
temp t1;
temp t2=temp(10);
temp t3=temp(t2);
```

值得一提的是 等号右侧的对象，被称为 **匿名对象**，即`temp(10)`这样的写法会被称为匿名对象。匿名对象执行完后系统会立即将它进行回收。

此外对于匿名对象，也不要用拷贝构造函数来声明，如`temp(t3);`这样写编译器会认为你要创建一个新的对象叫t3。

隐式转化法：

```cpp
temp t4=10;//这种写法等价于 temp t4=temp(10);
temp t5=t4;//这种写法等价于 temp t5=temp(t4);
```





















## 继承

### 继承的三种方式

继承共有三种方式，分别是公共继承，保护继承和私有继承语法如下:

```cpp
class father{
public:
    int a;
protected:
    int b;
private:
    int c;
};

class son_pub : public father{
    //继承 a 到public，继承 b 到protected中，c无法访问，实际上也被继承了，会占用内存，但不能访问，就是没继承。
};

class son_pro : protected father{
    //继承 a 和 b 到protected中，c 无法访问，实际上也被继承了，会占用内存，但不能访问，就是没继承。
};

class son_pri : private father{
    //继承 a 和 b 到private中， c 无法访问，实际上也被继承了，会占用内存，但不能访问，就是没继承。
};
```

其中`public`的继承方法，会将父类中除`private`内的成员原样继承下来。

而另外两种继承方式则会将父类中除`private`内的成员继承到`protected`或`private`中，也就是会将`public`一并转换成继承的方式。

要注意父类中的`private`实际上也被继承了下来，但是我们没法访问，但是它是**会占用内存的**。

### 继承时的析构和构造调用情况

```cpp
class son : public father{
    
}

int main(){
    son son1;
}
```

虽然在主函数中看到和father没什么关系，但是实际上调用顺序如下：父类的构造函数--->子类的构造函数--->子类析构函数--->父类析构函数。

### 继承中同名成员的处理

当子类中有父类的成员的同名成员变量和函数时，默认会使用子类中的成员，若想使用父类中的则需要添加作用域符号`son.father::a`。

需要注意的是，如果子类中出现和父类同名的成员函数，那么子类的同名成员会隐藏掉父类中所有的同名成员函数，也就是也不能访问父类中的同名重载函数，即子类中有父类的同名成员函数时，若想访问父类中的同名成员函数，包括重载的，都要加作用域符号。

### 菱形继承 虚继承问题

在继承的使用中有些时候我们会出现菱形继承的情况，何为菱形继承呢，假设现在有一个动物类，动物类





## 多态

多态可以分为静态多态和动态多态，其中**静态多态**就是**函数重载和运算符重载**。

区分静态和的动态多态的根本方法或者说边界，是**地址的绑定时机**，像函数重载和运算符重载，就是在编译时就已经确定好了地址，这就是地址的**早绑定**，而动态多态则是到了运行时才能确定要绑定的地址，地址是**晚绑定**，这就叫动态多态。

### 动态多态

动态多态实际上就是虚函数的应用，想要使用多态这个特性，需要满足几个条件：

1. 需要有继承关系
2. 需要父类类型的指针或引用
3. 需要子类对父类的虚函数进行重写

满足以上条件后就可以使用多态了。

```cpp
class Animal {
public:
	int mate;
	virtual void speak() {
		cout << "动物在说话" << endl;
	}
};


class Cat :public Animal {
	virtual void speak() {
		cout << "来福在说话" << endl;
	}
};

void dospeak(Animal& animal) {
	animal.speak();
}
int main(void) {
    //引用方式
	Cat cat;
	dospeak(cat);
    //指针方式
    Animal* an = new Cat;
	an->speak();
	return 0;
}
```

上面的代码运行后就会打印出“来福在说话”，因为我家的猫叫来福，而去掉`virtual`就会打印“动物在说话”。这就是动态多态。

### 动态多态的原理

那么动态多态是如何实现的呢，接来下简单说一下动态多态的大致原理。下面的动态多态就简称为多态了。

我们知道一个空的类所占用的内存是1个字节，那么上面的`Animal`类回占用多少内存呢，再正常的情况下应该是4个字节，因为只有`int mate`占用了4个字节，正常的成员函数是不占用类的内存的，而虚函数则不是，我们再函数前面加上了`virtual`后，在类中就会多出现一个指针`vfptr`就是虚函数指针的意思，这个指针指向了一个虚函数表，这个虚函数表中就有`Animal::speak()`这个函数的地址，当继承发生时，若在子类中对父类的虚函数进行了重写，那么子类的函数就会将子类的虚函数表覆写，让里面的内容变成`Cat::speak()`，当父类的指针或者引用指向子类对象的时候就发生了多态。

### 纯虚函数

在很多父类中它的虚函数是没有作用的，永远都不会被运行，更多的是在它的派生类中利用多态的方式运行，那么这个函数也就不需要有内容，针对这样的函数我们就可以使用**纯虚函数**。在类中只要包含一个纯虚函数，那么这个类就被称为**抽象类**，需要注意的是，如果一个派生类的父类是抽象类那么这个派生类必须要重写抽象类。纯虚函数的语法如下：

```cpp
virtual void func() = 0;
```

这样一个纯虚函数的创建就完成了。



### 抽象类的特点

抽象类有以下几个特点：

1. 抽象类无法实例化
2. 抽象类的派生类，若想实例化，就必须重写父类中的纯虚函数，否则它也属于抽象类，也无法实例化。 

总的来说纯虚函数和抽象类的存在就是为了避免派生类没有重写父函数中虚函数的情况，如果没有重写就使用（实例化）了这个派生类，会**导致编译不通过**。



### 虚析构和纯虚析构

在类的使用中，很多时候我们会在类的构造函数中申请一些内存，然后在类的析构函数中将它们释放，因为析构函数会在对象被销毁前调用，这样做就可以降低内存泄漏的风险，而在使用继承时我们需要注意，父类的指针在析构时，不会调用子类中的析构函数，即如下情况：

```cpp
Animal *animal = new Cat();
delete animal;
```

我们的本意是想要用`animal`这个指针删除Cat这个类，但是因为这个指针类型是Cat的父类Animal的指针，这就导致这一次delete操作只调用了父类Animal的析构函数（不要忘了在继承父类时会自动实例化父类），而没有调用子类Cat的析构函数，这就导致与我们最初的意愿并不一样，这个时候如果Cat的构造函数中有申请的内存，那么它就会被泄漏，针对**父类指针在析构的时候不会调用子类中析构函数**的这个问题，C++为我们提供了虚析构和纯虚析构。

#### 虚析构

先来说虚析构，实际上就是将动态多态用在了析构函数上语法也很类似

```cpp
virtual ~类名(){}
```



#### 纯虚析构

纯虚析构和纯虚函数有一点差别，就是有些时候父类也需要对本身的内容进行析构，但是又想使用纯虚析构避免子类没有重写析构函数，这种情况下就需要用到纯虚析构了。并且一个类如果使用了纯虚析构，那么它也会是一个**抽象类**，不能进行实例化。

纯虚析构语法如下：

```cpp
virtual ~类名()=0;
//如果父类也需要释放内存或在被销毁前进行操作时
类名::~类名(){/*操作内容*/}
```





### 优先级队列

在C++的STL中除了普通的queue队列，还有一种优先级队列，priority_queue，它相对于标准的队列来说，具有





## C/C++的内存泄漏问题

内存溢出（out of memory）OOM

### 造成内存泄漏常见的三种情况

1. 指针的重新赋值
2. 错误的内存释放
3. 返回值的不正确处理

#### 1.指针的重新赋值

当我们申请内存时，一般会先给这个内存申请一个指针用于存放该段内存的地址，但是如果我们在将这段内存归还前修改了存放内存的指针，那么如果不借助其他的工具，我们可能再也找不到这段内存所在的地址了，而内存的`delete\free`操作需要内存的地址，我们失去了它的地址也就再也没有办法归还它了，这段内存就被泄漏了。

#### 2.错误的内存释放

有时候我们会使用申请的内存来存放申请的内存的地址，即在一个申请的内存a中存放另外一个申请的内存b，这个时候我们如果删除了a也就再也找不到内存b的地址了，这也造成了内存的泄漏

#### 3.返回值的不正确处理

有时候我们会在一个函数中申请内存，并将内存的地址用返回值的方式返回，这个时候如果我们只调用函数，不接收返回值，这段申请的内存就被泄漏了，或者如果我们将接收到内存地址的指针重新赋值，也会导致内存的泄漏。

### 如何避免内存泄漏

- 确保没有在访问空指针。
- 每个内存分配函数都应该有一个 `free` 函数与之对应，`alloca` 函数除外。
- 每次分配内存之后都应该及时进行初始化，可以结合 `memset` 函数进行初始化，`calloc `函数除外。
- 每当向指针写入值时，都要确保对可用字节数和所写入的字节数进行交叉核对。
- 在对指针赋值前，一定要确保没有内存位置会变为孤立的。
- 每当释放结构化的元素（而该元素又包含指向动态分配的内存位置的指针）时，都应先遍历子内存位置并从那里开始释放，然后再遍历回父节点。
- 始终正确处理返回动态分配的内存引用的函数返回值。



## C++的内存分区

**1，内存分配的类型：**

在C/C++中[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)分为5个区，分别为**栈区、堆区、全局/静态存储区、常量存储区、代码区。**

**静态内存分配:**编译时分配。包括:全局、静态全局、静态局部三种变量。

**动态内存分配:**运行时分配。包括:栈(stack): 局部变量。堆(heap): c语言中用到的变量被动态的分配在内存中。([malloc](https://so.csdn.net/so/search?q=malloc&spm=1001.2101.3001.7020)或calloc、realloc、free函数)

**2.变量的内存分配：**

**栈区（stack）：**指那些由编译器在需要的时候分配，不需要时自动清除的变量所在的储存区，如函数执行时，函数的形参以及函数内的局部变量分配在栈区，函数运行结束后，形参和局部变量去栈（自动释放）。栈内存分配运算内置与处理器的指令集中，效率高但是分配的内存空间有限。

**堆区（heap）：**指哪些由程序员手动分配释放的储存区，如果程序员不释放这块内存，内存将一直被占用，直到程序运行结束由系统自动收回，c语言中使用malloc，free申请和释放空间。

**静态储存区（static）：**全局变量和静态变量的储存是放在一块的，其中初始化的全局变量和静态变量在一个区域，这块空间当程序运行结束后由系统释放。

**常量储存区（const）：**常量字符串就是储存在这里的，如“ABC”字符串就储存在常量区，储存在常量区的只读不可写。const修饰的全局变量也储存在常量区，const修饰的局部变量依然在栈上。

**程序代码区：**存放源程序的二进制代码。
